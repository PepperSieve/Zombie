/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   RReg    ********************/
RReg::RReg(Exp *p1)
{
  exp_ = p1;

}

RReg::RReg(const RReg & other)
{
  exp_ = other.exp_->clone();

}

RReg &RReg::operator=(const RReg & other)
{
  RReg tmp(other);
  swap(tmp);
  return *this;
}

void RReg::swap(RReg & other)
{
  std::swap(exp_, other.exp_);

}

RReg::~RReg()
{
  delete(exp_);

}

void RReg::accept(Visitor *v)
{
  v->visitRReg(this);
}

RReg *RReg::clone() const
{
  return new RReg(*this);
}



/********************   EConcat    ********************/
EConcat::EConcat(ListExp *p1)
{
  listexp_ = p1;

}

EConcat::EConcat(const EConcat & other)
{
  listexp_ = other.listexp_->clone();

}

EConcat &EConcat::operator=(const EConcat & other)
{
  EConcat tmp(other);
  swap(tmp);
  return *this;
}

void EConcat::swap(EConcat & other)
{
  std::swap(listexp_, other.listexp_);

}

EConcat::~EConcat()
{
  delete(listexp_);

}

void EConcat::accept(Visitor *v)
{
  v->visitEConcat(this);
}

EConcat *EConcat::clone() const
{
  return new EConcat(*this);
}



/********************   EUnion    ********************/
EUnion::EUnion(ListExp *p1)
{
  listexp_ = p1;

}

EUnion::EUnion(const EUnion & other)
{
  listexp_ = other.listexp_->clone();

}

EUnion &EUnion::operator=(const EUnion & other)
{
  EUnion tmp(other);
  swap(tmp);
  return *this;
}

void EUnion::swap(EUnion & other)
{
  std::swap(listexp_, other.listexp_);

}

EUnion::~EUnion()
{
  delete(listexp_);

}

void EUnion::accept(Visitor *v)
{
  v->visitEUnion(this);
}

EUnion *EUnion::clone() const
{
  return new EUnion(*this);
}



/********************   EStar    ********************/
EStar::EStar(Exp *p1)
{
  exp_ = p1;

}

EStar::EStar(const EStar & other)
{
  exp_ = other.exp_->clone();

}

EStar &EStar::operator=(const EStar & other)
{
  EStar tmp(other);
  swap(tmp);
  return *this;
}

void EStar::swap(EStar & other)
{
  std::swap(exp_, other.exp_);

}

EStar::~EStar()
{
  delete(exp_);

}

void EStar::accept(Visitor *v)
{
  v->visitEStar(this);
}

EStar *EStar::clone() const
{
  return new EStar(*this);
}



/********************   EMore    ********************/
EMore::EMore(Exp *p1)
{
  exp_ = p1;

}

EMore::EMore(const EMore & other)
{
  exp_ = other.exp_->clone();

}

EMore &EMore::operator=(const EMore & other)
{
  EMore tmp(other);
  swap(tmp);
  return *this;
}

void EMore::swap(EMore & other)
{
  std::swap(exp_, other.exp_);

}

EMore::~EMore()
{
  delete(exp_);

}

void EMore::accept(Visitor *v)
{
  v->visitEMore(this);
}

EMore *EMore::clone() const
{
  return new EMore(*this);
}



/********************   ERepe    ********************/
ERepe::ERepe(Exp *p1)
{
  exp_ = p1;

}

ERepe::ERepe(const ERepe & other)
{
  exp_ = other.exp_->clone();

}

ERepe &ERepe::operator=(const ERepe & other)
{
  ERepe tmp(other);
  swap(tmp);
  return *this;
}

void ERepe::swap(ERepe & other)
{
  std::swap(exp_, other.exp_);

}

ERepe::~ERepe()
{
  delete(exp_);

}

void ERepe::accept(Visitor *v)
{
  v->visitERepe(this);
}

ERepe *ERepe::clone() const
{
  return new ERepe(*this);
}



/********************   EMult    ********************/
EMult::EMult(Exp *p1, Rang p2)
{
  exp_ = p1;
  rang_ = p2;

}

EMult::EMult(const EMult & other)
{
  exp_ = other.exp_->clone();
  rang_ = other.rang_;

}

EMult &EMult::operator=(const EMult & other)
{
  EMult tmp(other);
  swap(tmp);
  return *this;
}

void EMult::swap(EMult & other)
{
  std::swap(exp_, other.exp_);
  std::swap(rang_, other.rang_);

}

EMult::~EMult()
{
  delete(exp_);

}

void EMult::accept(Visitor *v)
{
  v->visitEMult(this);
}

EMult *EMult::clone() const
{
  return new EMult(*this);
}



/********************   EClas    ********************/
EClas::EClas(ListSymb *p1)
{
  listsymb_ = p1;

}

EClas::EClas(const EClas & other)
{
  listsymb_ = other.listsymb_->clone();

}

EClas &EClas::operator=(const EClas & other)
{
  EClas tmp(other);
  swap(tmp);
  return *this;
}

void EClas::swap(EClas & other)
{
  std::swap(listsymb_, other.listsymb_);

}

EClas::~EClas()
{
  delete(listsymb_);

}

void EClas::accept(Visitor *v)
{
  v->visitEClas(this);
}

EClas *EClas::clone() const
{
  return new EClas(*this);
}



/********************   EAStr    ********************/
EAStr::EAStr(ListSymb *p1)
{
  listsymb_ = p1;

}

EAStr::EAStr(const EAStr & other)
{
  listsymb_ = other.listsymb_->clone();

}

EAStr &EAStr::operator=(const EAStr & other)
{
  EAStr tmp(other);
  swap(tmp);
  return *this;
}

void EAStr::swap(EAStr & other)
{
  std::swap(listsymb_, other.listsymb_);

}

EAStr::~EAStr()
{
  delete(listsymb_);

}

void EAStr::accept(Visitor *v)
{
  v->visitEAStr(this);
}

EAStr *EAStr::clone() const
{
  return new EAStr(*this);
}




/********************   ListReg    ********************/

void ListReg::accept(Visitor *v)
{
  v->visitListReg(this);
}

ListReg *ListReg::clone() const
{
  return new ListReg(*this);
}

ListReg* consListReg(Reg* x, ListReg* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}

ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}

ListExp* consListExp(Exp* x, ListExp* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListSymb    ********************/

void ListSymb::accept(Visitor *v)
{
  v->visitListSymb(this);
}

ListSymb *ListSymb::clone() const
{
  return new ListSymb(*this);
}

ListSymb* consListSymb(Symb x, ListSymb* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





