/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the regex_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE regex__scan_string(const char *str, yyscan_t scanner);
extern void regex__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void regex_lex_destroy(yyscan_t scanner);
extern char* regex_get_text(yyscan_t scanner);

extern yyscan_t regex__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  ListReg* listreg_;
  Reg* reg_;
  Exp* exp_;
  ListExp* listexp_;
  ListSymb* listsymb_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, regex_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _AMP       /* & */
%token          _LPAREN    /* ( */
%token          _RPAREN    /* ) */
%token          _STAR      /* * */
%token          _PLUS      /* + */
%token          _QUESTION  /* ? */
%token          _LBRACK    /* [ */
%token          _RBRACK    /* ] */
%token          _BAR       /* | */
%token<_string> T_Rang     /* Rang */
%token<_string> T_Symb     /* Symb */

%type <listreg_> ListReg
%type <reg_> Reg
%type <exp_> Exp
%type <exp_> Exp1
%type <exp_> Exp2
%type <exp_> Exp3
%type <listexp_> ListExp1
%type <listexp_> ListExp2
%type <listsymb_> ListSymb

%start ListReg

%%

ListReg : Reg { $$ = new ListReg(); $$->push_back($1); result->listreg_ = $$; }
  | Reg _AMP ListReg { $3->push_back($1); $$ = $3; result->listreg_ = $$; }
;
Reg : Exp { $$ = new RReg($1); result->reg_ = $$; }
;
Exp : ListExp1 { $$ = new EConcat($1); result->exp_ = $$; }
;
Exp1 : ListExp2 { std::reverse($1->begin(),$1->end()) ;$$ = new EUnion($1); result->exp_ = $$; }
;
Exp2 : Exp3 { $$ = $1; result->exp_ = $$; }
;
Exp3 : _LPAREN Exp _RPAREN { $$ = $2; result->exp_ = $$; }
  | Exp3 _STAR { $$ = new EStar($1); result->exp_ = $$; }
  | Exp3 _PLUS { $$ = new EMore($1); result->exp_ = $$; }
  | Exp3 _QUESTION { $$ = new ERepe($1); result->exp_ = $$; }
  | Exp3 T_Rang { $$ = new EMult($1, $2); result->exp_ = $$; }
  | _LBRACK ListSymb _RBRACK { std::reverse($2->begin(),$2->end()) ;$$ = new EClas($2); result->exp_ = $$; }
  | ListSymb { std::reverse($1->begin(),$1->end()) ;$$ = new EAStr($1); result->exp_ = $$; }
;
ListExp1 : /* empty */ { $$ = new ListExp(); result->listexp_ = $$; }
  | ListExp1 Exp1 { $1->push_back($2); $$ = $1; result->listexp_ = $$; }
;
ListExp2 : Exp2 { $$ = new ListExp(); $$->push_back($1); result->listexp_ = $$; }
  | Exp2 _BAR ListExp2 { $3->push_back($1); $$ = $3; result->listexp_ = $$; }
;
ListSymb : T_Symb { $$ = new ListSymb(); $$->push_back($1); result->listsymb_ = $$; }
  | T_Symb ListSymb { $2->push_back($1); $$ = $2; result->listsymb_ = $$; }
;

%%


/* Entrypoint: parse ListReg* from file. */
ListReg* pListReg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listreg_->begin(), result.listreg_->end());
    return result.listreg_;
  }
}

/* Entrypoint: parse ListReg* from string. */
ListReg* psListReg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listreg_->begin(), result.listreg_->end());
    return result.listreg_;
  }
}

/* Entrypoint: parse Reg* from file. */
Reg* pReg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.reg_;
  }
}

/* Entrypoint: parse Reg* from string. */
Reg* psReg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.reg_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse ListExp* from file. */
ListExp* pListExp1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listexp_;
  }
}

/* Entrypoint: parse ListExp* from string. */
ListExp* psListExp1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listexp_;
  }
}

/* Entrypoint: parse ListExp* from file. */
ListExp* pListExp2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexp_->begin(), result.listexp_->end());
    return result.listexp_;
  }
}

/* Entrypoint: parse ListExp* from string. */
ListExp* psListExp2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexp_->begin(), result.listexp_->end());
    return result.listexp_;
  }
}

/* Entrypoint: parse ListSymb* from file. */
ListSymb* pListSymb(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listsymb_->begin(), result.listsymb_->end());
    return result.listsymb_;
  }
}

/* Entrypoint: parse ListSymb* from string. */
ListSymb* psListSymb(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = regex__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = regex__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  regex__delete_buffer(buf, scanner);
  regex_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listsymb_->begin(), result.listsymb_->end());
    return result.listsymb_;
  }
}



