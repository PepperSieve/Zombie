/* Skeleton of File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern Interpreter. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "Interpreter.H"

void Interpreter::visitReg(Reg *t) {} //abstract class
void Interpreter::visitExp(Exp *t) {} //abstract class

void Interpreter::visitRReg(RReg *r_reg) {
  // visit regular expression
  if (r_reg->exp_) r_reg->exp_->accept(this);
  // add treeRet to forest
  data.forest.push_back(treeRet);
  // apply optimizations according to analysis setting
  if (stringPreprocess) {
    data.forest.back().optimize();
  } else if (!stringMatch) {
    data.forest.back().nostring();
  }
}

void Interpreter::visitEConcat(EConcat *e_concat) {
  if (e_concat->listexp_->size() == 1) { // passthrough
    e_concat->listexp_->at(0)->accept(this);
  } else {
    // create RegTree for concat
    RegTree tree(RegTree::CONCAT);
    // loop over children and append to tree
    for (uint i = 0; i < e_concat->listexp_->size(); i++) {
      e_concat->listexp_->at(i)->accept(this);
      tree.addChild(treeRet);
    }
    // return tree
    treeRet = tree;
  }
}

void Interpreter::visitEUnion(EUnion *e_union) {
  if (e_union->listexp_->size() == 1) { // passthrough
    e_union->listexp_->at(0)->accept(this);
  } else {
    // create RegTree for union
    RegTree tree(RegTree::UNION);
    // loop over children and append to tree
    for (uint i = 0; i < e_union->listexp_->size(); i++) {
      e_union->listexp_->at(i)->accept(this);
      tree.addChild(treeRet);
    }
    // return tree
    treeRet = tree;
  }
}

void Interpreter::visitEStar(EStar *e_star) {
  // create RegTree for star
  RegTree tree(RegTree::STAR);
  // explore and add child
  if (e_star->exp_) e_star->exp_->accept(this);
  tree.addChild(treeRet);
  // return tree
  treeRet = tree;
}

void Interpreter::visitERepe(ERepe *e_repe) {
  // create RegTree for repeat
  RegTree tree(RegTree::REPEAT);
  // explore and add child
  if (e_repe->exp_) e_repe->exp_->accept(this);
  tree.addChild(treeRet);
  // return tree
  treeRet = tree;
}

std::vector<int> Interpreter::parseRang(std::string s) {
  // parse range by removing brackets and splitting on comma
  std::string range = s;
  range = range.substr(1, range.size() - 2);
  std::stringstream s_stream(range);
  std::vector<int> r_vec;
  while (s_stream.good()) {
    std::string substr;
    getline(s_stream, substr, ',');
    if (substr.length() == 0) {
      r_vec.push_back(-1);
    } else {
      r_vec.push_back(std::stoi(substr));
    }
  }
  return r_vec;
}

// There is potentially a better way to do this
void Interpreter::visitEMult(EMult *e_mult) {
  // get child
  if (e_mult->exp_) e_mult->exp_->accept(this);
  RegTree child = treeRet;
  // parse range by removing brackets and splitting on comma
  std::vector<int> r_vec = parseRang(e_mult->rang_);
  // if range contains one item
  if (r_vec.size() == 1) {
    // create RegTree for mult (macro for concat)
    RegTree tree(RegTree::CONCAT);
    for (int i = 1; i <= r_vec[0]; i++) {
      tree.addChild(child);
    }
    treeRet = tree;
  } else if (r_vec[0] == -1) { // otherwise if left is empty
    int extra = r_vec[1];
    int db = 1;
    RegTree tree(RegTree::CONCAT);
    while(db <= extra) {
      RegTree sum(RegTree::CONCAT);
      for (int i = 0; i < db; i++) { sum.addChild(child); }
      RegTree rep(RegTree::REPEAT);
      rep.addChild(sum);
      tree.addChild(rep);
      extra -= db;
      db *= 2;
    }
    if (extra > 0) {
      RegTree sum(RegTree::CONCAT);
      for (int i = 0; i < extra; i++) { sum.addChild(child); }
      RegTree rep(RegTree::REPEAT);
      rep.addChild(sum);
      tree.addChild(rep);
    }
    treeRet = tree;
  } else if (r_vec[1] == -1) { // otherwise if right is empty
    // this is the easier case of the two (concat + star)
    RegTree tree(RegTree::CONCAT);
    for (int i = 1; i <= r_vec[0]; i++) { tree.addChild(child); }
    RegTree star(RegTree::STAR);
    star.addChild(child);
    tree.addChild(star);
    treeRet = tree;
  } else { // otherwise if both are non-empty
    assert(r_vec[0] <= r_vec[1]);
    // concat the first r_vec[0] children
    RegTree tree(RegTree::CONCAT);
    for (int i = 1; i <= r_vec[0]; i++) { tree.addChild(child); }
    // then create a binary list of ?'s to cover the rest
    // ex. if the range is 3-11 then we have 3 and need to be able to reach 0, 1, 2, 3, 4, 5, 6, 7, 8 additional pattern repeats
    // we can do this by adding 1, 2, 4, 1 so all sums can be made
    int extra = r_vec[1] - r_vec[0];
    int db = 1;
    while(db <= extra) {
      RegTree sum(RegTree::CONCAT);
      for (int i = 0; i < db; i++) { sum.addChild(child); }
      RegTree rep(RegTree::REPEAT);
      rep.addChild(sum);
      tree.addChild(rep);
      extra -= db;
      db *= 2;
    }
    if (extra > 0) {
      RegTree sum(RegTree::CONCAT);
      for (int i = 0; i < extra; i++) { sum.addChild(child); }
      RegTree rep(RegTree::REPEAT);
      rep.addChild(sum);
      tree.addChild(rep);
    }
    treeRet = tree;
  }
}

void Interpreter::visitEMore(EMore *e_more) {
  // create RegTree for more
  RegTree tree(RegTree::MORE);
  // explore and add child
  if (e_more->exp_) e_more->exp_->accept(this);
  tree.addChild(treeRet);
  // return tree
  treeRet = tree;
}

void Interpreter::visitEClas(EClas *e_clas) {
  // if the first or last character is -, then error out
  if (e_clas->listsymb_->at(0)[0] == '-' ||
      e_clas->listsymb_->at(e_clas->listsymb_->size() - 1)[0] == '-') {
    std::cerr << "Error: '-' cannot be the first or last character in a character class." << std::endl;
    exit(1);
  }
  // create RegTree for class
  RegTree tree(RegTree::ATOM);
  // if first character is ^, then we have a negated class
  bool negated = (e_clas->listsymb_->at(0)[0] == '^');
  if (negated) {
    // check that if there is a second character, it is not a -
    if (e_clas->listsymb_->size() > 1 && e_clas->listsymb_->at(1)[0] == '-') {
      std::cerr << "Error: '-' cannot be the first or last character in a character class." << std::endl;
      exit(1);
    }
    // add all characters to classTree
    for (int c = 0; c < 256; c++) { tree.symbols.insert((char)c); }
  }
  // keep track of last character for ranges
  char last = ' ';
  bool range = false;
  // loop over children and append to tree
  for (uint i = negated ? 1 : 0; i < e_clas->listsymb_->size(); i++) {
    // if symbol is ^, then error out
    switch (e_clas->listsymb_->at(i)[0]) {
      case '^':
        std::cerr << "Error: '^' must be first in character class." << std::endl;
        exit(1);
      case '.':
        std::cerr << "Error: '.' wildcard is not allowed in character class." << std::endl;
        exit(1);
      case '-':
        if (range) {
          std::cerr << "Error: Two '-' in a row" << std::endl;
          exit(1);
        }
        range = true;
        break;
      default:
        char x = parseSymb(e_clas->listsymb_->at(i));
        if (range) {
          // ensure range is correct direction, otherwise swap
          if (x < last) {
            char tmp = x;
            x = last;
            last = tmp;
          }
          // add range to classTree
          for (char c = last; c <= x; c++) {
            if (negated) tree.removeSymbol(c); 
            else tree.addSymbol(c);
          }
          range = false;
          // if next character is -, then error out
          if (i < e_clas->listsymb_->size() - 1 && e_clas->listsymb_->at(i + 1)[0] == '-') {
            std::cerr << "Error: Two '-' too close, no semantic meaning." << std::endl;
            exit(1);
          }
        } else {
          // add symbol to classTree
          if (negated) tree.removeSymbol(x);
          else tree.addSymbol(x);
          last = x;
        }
    }
  }
  if (tree.symbols.size() == 0) {
    std::cerr << "Error: Empty character class." << std::endl;
    exit(1);
  }
  // return tree
  treeRet = tree;
}

// EAStr is like EConcat, but we are assured that the is no List, Star, or Union
void Interpreter::visitEAStr(EAStr *ea_str) {
  // create RegTree for concat
  RegTree tree(RegTree::CONCAT);
  // loop over children and append to tree
  for (uint i = 0; i < ea_str->listsymb_->size(); i++) {
    // create RegTree for character
    RegTree tmpTree(RegTree::ATOM);
    switch (ea_str->listsymb_->at(i)[0]) {
      case '^':
        std::cerr << "Error: '^' not allowed outside character class." << std::endl;
        exit(1);
      case '-':
        std::cerr << "Error: '-' not allowed outside character class." << std::endl;
        exit(1);
      case '.':
        // add all characters to tree
        tmpTree.addAllSymbols();
        break;
      default:
        // add symbol to tree
        tmpTree.addSymbol(parseSymb(ea_str->listsymb_->at(i)));
        break;
    }
    // add tree to tree
    tree.addChild(tmpTree);
  }
  // if tree has more than one child return tree otherwise return child
  if (tree.children.size() == 1) treeRet = tree.children[0];
  else treeRet = tree;
}

void Interpreter::visitListReg(ListReg *list_reg) {
  for (ListReg::iterator i = list_reg->begin() ; i != list_reg->end() ; ++i) {
    (*i)->accept(this);
  }
}

void Interpreter::visitListExp(ListExp *list_exp) {
  std::cerr << "COMPILER BUG! Should not be here!" << std::endl;
  exit(-1);
}

void Interpreter::visitListSymb(ListSymb *list_symb) {
  std::cerr << "COMPILER BUG! Should not be here!" << std::endl;
  exit(-1);
}

void Interpreter::visitSymb(Symb x) {
  std::cerr << "COMPILER BUG! Should not be here!" << std::endl;
  exit(-1);
}

void Interpreter::visitRang(Rang x) {
  std::cerr << "COMPILER BUG! Should not be here!" << std::endl;
  exit(-1);
}

char Interpreter::parseHex(char x) {
  if (x >= '0' && x <= '9') {
    return x - '0';
  } else if (x >= 'a' && x <= 'f') {
    return x - 'a' + 10;
  } else if (x >= 'A' && x <= 'F') {
    return x - 'A' + 10;
  } else {
    std::cerr << "Error: invalid hexidecimal character." << std::endl;
    exit(1);
  }
}

char Interpreter::parseSymb(Symb x) {
  if (x[0] == '\\') {
    return 16 * parseHex(x[2]) + parseHex(x[3]);
  } else {
    return x[0];
  }
}
