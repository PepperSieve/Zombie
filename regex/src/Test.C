/* File Skeleton generated by the BNF Converter (bnfc 2.9.4). */

#include <cstdio>
#include <string>
#include <iostream>
#include <utility>
#include <algorithm>
#include "builder/Interpreter.H"
#include "builder/RegTree.H"
#include "builder/FABuilder.H"
#include "builder/ZokWriter.H"
#include "builder/ZokCounter.H"
#include "compiler/Parser.H"
#include "compiler/Printer.H"
#include "compiler/Absyn.H"
#include "compiler/ParserError.H"

int main(int argc, char ** argv) {
  // check that number of args is odd
  if (argc % 2) {
    std::cout << "Usage: " << argv[0] << " <analysis setting [A-F]> <list of proximity pairs>" << std::endl;
    std::cout << " analysis setting:" << std::endl;
    std::cout << "  A. no match, no alt arith, no preprocess, no tapes, no class opt" << std::endl;
    std::cout << "  B. match, no alt arith, no preprocess, no tapes, no class opt" << std::endl;
    std::cout << "  C. match, alt arith, no preprocess, no tapes, no class opt" << std::endl;
    std::cout << "  D. match, alt arith, preprocess, no tapes, no class opt" << std::endl;
    std::cout << "  E. match, alt arith, preprocess, tapes, no class opt" << std::endl;
    std::cout << "  F. match, alt arith, preprocess, tapes, class opt" << std::endl;
    std::cout << "For example: " << argv[0] << "A 1 3 4 5" << std::endl;
    std::cout << " this would create proximity checks between patterns 1 and 3 and 4 and 5" << std::endl;
    std::cout << " and just enforce non-membership for 0, 2, and anything >= 6 individually" << std::endl;
    std::cout << " and would not perform any optimizations" << std::endl;
    std::cout << "Regexps are read from stdin and should be delimited by an '&' character" << std::endl;
    std::cout << "Special characters should be specified inline as their base 16 ASCII code: ex. \\x20 for space" << std::endl;
    return 0;
  }
  // check that analysis setting is valid and set booleans accordingly
  char analysisSetting = argv[1][0];
  bool match = (analysisSetting >= 'B');
  bool altArith = (analysisSetting >= 'C');
  bool preprocess = (analysisSetting >= 'D');
  bool tapes = (analysisSetting >= 'E');
  bool classOpt = (analysisSetting >= 'F');
  // loop over args, store them in a vector of pairs
  std::vector<std::pair<int, int>> proximityPairs;
  for (int i = 2; i < argc; i += 2) {
    proximityPairs.push_back(std::make_pair(atoi(argv[i]), atoi(argv[i+1])));
  }
  ListReg *parse_tree = NULL;
  try {
    parse_tree = pListReg(stdin);
  } catch( parse_error &e) {
    std::cerr << "Parse error on line " << e.getLine() << "\n";
    exit(-1);
  }
  if (parse_tree) {
    printf("Parse Successful!\n");
    #ifdef DEBUG
      ShowAbsyn *s = new ShowAbsyn();
      printf("[Abstract Syntax]\n");
      printf("%s\n\n", s->show(parse_tree));
    #endif
    #ifdef DEBUG
      PrintAbsyn *p = new PrintAbsyn();
      printf("[Linearized Tree]\n");
      printf("%s\n\n", p->print(parse_tree));
    #endif
    Interpreter i;
    i.stringMatch = match;
    i.stringPreprocess = preprocess;
    i.visitListReg(parse_tree);
    #ifdef DEBUG
      printf("[Regex Tree]\n");
      for (uint j = 0; j < i.data.forest.size(); j++) {
        i.data.forest[j].print();
      }
    #endif
    FABuilder f;
    f.parseForest(i.data.forest);
    #ifdef DEBUG
      printf("[Automata]\n");
      f.print();
      f.graphVizPrint();
    #endif
    if (classOpt) {
      printf("[Zokrates Code]\n");
      ZokWriter zw;
      zw.faToZok(f, proximityPairs);
    } else {
      printf("[Constraint Estimates]\n");
      ZokCounter zc;
      zc.faToCount(f, proximityPairs, altArith, tapes);
    }
  }
  return 0;
}

